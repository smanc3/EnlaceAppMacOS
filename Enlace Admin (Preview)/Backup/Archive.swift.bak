//
//  Archive.swift
//  Enlace Admin (Preview)
//
//  Created by Steven Mancilla on 2/25/25.
//

import SwiftUI
import CloudKit

struct PopupView3: View {
    @Binding var showPopupArchive: Bool  // Control popup visibility
    @Binding var isSpanish: Bool      // Control language selection
    var onEventArchived: (() -> Void)? = nil  // Callback for when an event is archived

    @State private var selectedEventID: String = ""
    @State private var events: [CalendarEvent] = []
    @State private var isLoading: Bool = false
    @State private var errorMessage: String? = nil
    @State private var showAlert: Bool = false
    @State private var alertMessage: String = ""
    @State private var archiveDate: Date = Date()
    @State private var showConfirmation: Bool = false
    @State private var selectedEvent: CalendarEvent? = nil
    
    private let container = CKContainer(identifier: "iCloud.PearInc.EICT-iOS-16")
    private var database: CKDatabase {
        return container.publicCloudDatabase
    }

    var body: some View {
        ZStack {
            // Dimmed background
            Color.black.opacity(0.1)
                .edgesIgnoringSafeArea(.all)
                .onTapGesture {
                    showPopupArchive = false
                }

            VStack(spacing: 15) {
                // Title
                Text(isSpanish ? "Archivar Evento" : "Archive Event")
                    .font(.title)
                    .fontWeight(.bold)
                
                if isLoading {
                    ProgressView()
                        .progressViewStyle(CircularProgressViewStyle())
                        .scaleEffect(1.2)
                        .padding()
                } else if let error = errorMessage {
                    Text(error)
                        .foregroundColor(.red)
                        .padding()
                } else {
                    ScrollView {
                        VStack(spacing: 12) {
                            // Event Picker
                            Picker(
                                isSpanish ? "Seleccionar Evento" : "Select Event",
                                selection: $selectedEventID
                            ) {
                                Text(isSpanish ? "Seleccione un evento" : "Select an event")
                                    .tag("")
                                
                                ForEach(events) { event in
                                    Text(event.title)
                                        .tag(event.recordNameMirror)
                                }
                            }
                            .pickerStyle(.menu)
                            .padding(.horizontal)
                            .onChange(of: selectedEventID) { oldValue, newValue in
                                selectedEvent = events.first(where: { $0.recordNameMirror == newValue })
                            }
                            
                            if let event = selectedEvent {
                                // Event details
                                VStack(alignment: .leading, spacing: 8) {
                                    Text(isSpanish ? "Detalles del evento:" : "Event details:")
                                        .font(.subheadline)
                                        .fontWeight(.bold)
                                    
                                    HStack {
                                        Text(isSpanish ? "Fecha:" : "Date:")
                                            .fontWeight(.medium)
                                        Text(DateFormatter.localizedString(from: event.startDate, dateStyle: .medium, timeStyle: .short))
                                    }
                                    
                                    HStack {
                                        Text(isSpanish ? "Ubicación:" : "Location:")
                                            .fontWeight(.medium)
                                        Text(event.location)
                                    }
                                }
                                .padding()
                                .background(Color(NSColor.controlBackgroundColor))
                                .cornerRadius(8)
                                .padding(.horizontal)
                            }
                            
                            // DatePicker
                            DatePicker(
                                isSpanish ? "Fecha de Archivo" : "Archive Date",
                                selection: $archiveDate
                            )
                            .datePickerStyle(.compact)
                            .padding(.horizontal)
                        }
                    }
                    
                    // Archive and Cancel Buttons
                    HStack {
                        Button(isSpanish ? "Cancelar" : "Cancel") {
                            showPopupArchive = false
                        }
                        .keyboardShortcut(.escape, modifiers: [])
                        .buttonStyle(.bordered)
                        
                        Spacer()
                        
                        Button(isSpanish ? "Archivar" : "Archive") {
                            showConfirmation = true
                        }
                        .buttonStyle(.borderedProminent)
                        .disabled(selectedEventID.isEmpty)
                    }
                    .padding(.horizontal)
                    .padding(.top, 8)
                    .padding(.bottom, 10)
                }
            }
            .frame(width: 400, height: 400)
            .background(Color(NSColor.windowBackgroundColor))
            .cornerRadius(12)
            .shadow(radius: 10)
            .alert(isPresented: $showAlert) {
                Alert(
                    title: Text(isSpanish ? "Notificación" : "Notification"),
                    message: Text(alertMessage),
                    dismissButton: .default(Text("OK"))
                )
            }
            .alert(isSpanish ? "Confirmar archivo" : "Confirm Archive", isPresented: $showConfirmation) {
                Button(isSpanish ? "Cancelar" : "Cancel", role: .cancel) { }
                Button(isSpanish ? "Archivar" : "Archive", role: .destructive) {
                    archiveSelectedEvent()
                }
            } message: {
                Text(isSpanish ? 
                    "¿Está seguro de que desea archivar este evento? Esta acción eliminará el evento del calendario activo." : 
                    "Are you sure you want to archive this event? This action will remove the event from the active calendar.")
            }
            .onAppear {
                loadEvents()
            }
        }
    }
    
    private func loadEvents() {
        isLoading = true
        errorMessage = nil
        
        let query = CKQuery(recordType: "CalendarEvent", predicate: NSPredicate(value: true))
        query.sortDescriptors = [NSSortDescriptor(key: "startDate", ascending: true)]
        
        database.fetch(withQuery: query, inZoneWith: nil, desiredKeys: nil, resultsLimit: 50) { result in
            DispatchQueue.main.async {
                self.isLoading = false
                
                switch result {
                case .success(let matchResults):
                    let records = matchResults.matchResults.compactMap { (recordID, recordResult) -> CKRecord? in
                        if case .success(let record) = recordResult {
                            // Ensure recordNameMirror is set
                            if record["recordNameMirror"] == nil {
                                record["recordNameMirror"] = record.recordID.recordName
                                
                                // Save the updated record with recordNameMirror in the background
                                DispatchQueue.global(qos: .background).async {
                                    self.database.save(record) { _, error in
                                        if let error = error {
                                            print("Error updating recordNameMirror: \(error.localizedDescription)")
                                        }
                                    }
                                }
                            }
                            return record
                        }
                        return nil
                    }
                    self.events = records.map { CalendarEvent(record: $0) }
                    
                case .failure(let error):
                    // Enhanced error handling for schema or permission issues
                    let errorCode = (error as NSError).code
                    if errorCode == CKError.unknownItem.rawValue {
                        self.errorMessage = isSpanish ?
                            "Error: El tipo 'CalendarEvent' no está marcado como indexable en CloudKit. Verifique el Dashboard de CloudKit." :
                            "Error: 'CalendarEvent' type is not marked as indexable in CloudKit. Please check CloudKit Dashboard."
                    } else if errorCode == CKError.notAuthenticated.rawValue || errorCode == CKError.permissionFailure.rawValue {
                        self.errorMessage = isSpanish ?
                            "Error de permisos: No tiene permisos para acceder a CloudKit. Verifique su sesión de iCloud." :
                            "Permission error: You don't have permissions to access CloudKit. Please check your iCloud session."
                    } else {
                        self.errorMessage = isSpanish ? 
                            "Error al cargar eventos: \(error.localizedDescription)" : 
                            "Error loading events: \(error.localizedDescription)"
                    }
                    print("CloudKit Error (\(errorCode)): \(error.localizedDescription)")
                }
            }
        }
    }
    
    private func archiveSelectedEvent() {
        guard !selectedEventID.isEmpty else { return }
        
        isLoading = true
        errorMessage = nil
        
        // Check if the event exists
        if !events.contains(where: { event in event.recordNameMirror == selectedEventID }) {
            isLoading = false
            errorMessage = isSpanish ? "Evento no encontrado" : "Event not found"
            return
        }
        
        // Create a new ArchivedEvent record
        let archivedRecord = CKRecord(recordType: "ArchivedEvent")
        
        // Find the original event record using recordNameMirror
        let predicate = NSPredicate(format: "recordNameMirror == %@", selectedEventID)
        let query = CKQuery(recordType: "CalendarEvent", predicate: predicate)
        
        database.fetch(withQuery: query, inZoneWith: nil, desiredKeys: nil, resultsLimit: 1) { result in
            switch result {
            case .success(let matchResults):
                if let firstMatch = matchResults.matchResults.first, case .success(let originalRecord) = firstMatch.1 {
                    // Copy data from original event to archived event
                    archivedRecord["title"] = originalRecord["title"]
                    archivedRecord["startDate"] = originalRecord["startDate"]
                    archivedRecord["endDate"] = originalRecord["endDate"]
                    archivedRecord["location"] = originalRecord["location"]
                    archivedRecord["notes"] = originalRecord["notes"]
                    archivedRecord["pdfReference"] = originalRecord["pdfReference"]
                    archivedRecord["archivedDate"] = self.archiveDate
                    
                    // IMPORTANT: Set recordNameMirror for queryability
                    archivedRecord["recordNameMirror"] = archivedRecord.recordID.recordName
                    
                    // Save the archived event to CloudKit
                    self.database.save(archivedRecord) { savedRecord, saveError in
                        if let saveError = saveError {
                            DispatchQueue.main.async {
                                self.isLoading = false
                                
                                // Enhanced error handling for schema or permission issues
                                let errorCode = (saveError as NSError).code
                                if errorCode == CKError.unknownItem.rawValue {
                                    self.errorMessage = self.isSpanish ?
                                        "Error: El tipo 'ArchivedEvent' no está marcado como indexable en CloudKit. Verifique el Dashboard de CloudKit." :
                                        "Error: 'ArchivedEvent' type is not marked as indexable in CloudKit. Please check CloudKit Dashboard."
                                } else if errorCode == CKError.notAuthenticated.rawValue || errorCode == CKError.permissionFailure.rawValue {
                                    self.errorMessage = self.isSpanish ?
                                        "Error de permisos: No tiene permisos para guardar en CloudKit." :
                                        "Permission error: You don't have permissions to save to CloudKit."
                                } else {
                                    self.errorMessage = self.isSpanish ?
                                        "Error al archivar el evento: \(saveError.localizedDescription)" :
                                        "Error archiving event: \(saveError.localizedDescription)"
                                }
                                print("CloudKit Save Error (\(errorCode)): \(saveError.localizedDescription)")
                            }
                            return
                        }
                        
                        // Delete the original event
                        self.database.delete(withRecordID: originalRecord.recordID) { _, deleteError in
                            DispatchQueue.main.async {
                                self.isLoading = false
                                
                                if let deleteError = deleteError {
                                    // Enhanced error handling for delete errors
                                    let errorCode = (deleteError as NSError).code
                                    if errorCode == CKError.permissionFailure.rawValue {
                                        self.alertMessage = self.isSpanish ?
                                            "Evento archivado pero no se pudo eliminar el original por falta de permisos." :
                                            "Event archived but could not delete original due to permission issues."
                                    } else {
                                        self.alertMessage = self.isSpanish ?
                                            "Evento archivado pero no se pudo eliminar el original: \(deleteError.localizedDescription)" :
                                            "Event archived but could not delete original: \(deleteError.localizedDescription)"
                                    }
                                    print("CloudKit Delete Error (\(errorCode)): \(deleteError.localizedDescription)")
                                } else {
                                    self.alertMessage = self.isSpanish ?
                                        "Evento archivado exitosamente" :
                                        "Event successfully archived"
                                    
                                    // Call the callback
                                    self.onEventArchived?()
                                }
                                
                                self.showAlert = true
                                self.showPopupArchive = false
                            }
                        }
                    }
                } else {
                    DispatchQueue.main.async {
                        self.isLoading = false
                        self.errorMessage = self.isSpanish ? "Evento no encontrado" : "Event not found"
                    }
                }
                
            case .failure(let error):
                DispatchQueue.main.async {
                    self.isLoading = false
                    
                    // Enhanced error handling for schema or permission issues
                    let errorCode = (error as NSError).code
                    if errorCode == CKError.unknownItem.rawValue {
                        self.errorMessage = self.isSpanish ?
                            "Error: El tipo 'CalendarEvent' no está marcado como indexable en CloudKit o el campo 'recordNameMirror' no existe. Verifique el Dashboard de CloudKit." :
                            "Error: 'CalendarEvent' type is not marked as indexable in CloudKit or the 'recordNameMirror' field doesn't exist. Please check CloudKit Dashboard."
                    } else if errorCode == CKError.notAuthenticated.rawValue || errorCode == CKError.permissionFailure.rawValue {
                        self.errorMessage = self.isSpanish ?
                            "Error de permisos: No tiene permisos para consultar CloudKit. Verifique su sesión de iCloud." :
                            "Permission error: You don't have permissions to query CloudKit. Please check your iCloud session."
                    } else {
                        self.errorMessage = self.isSpanish ?
                            "Error al recuperar el evento: \(error.localizedDescription)" :
                            "Error retrieving event: \(error.localizedDescription)"
                    }
                    print("CloudKit Query Error (\(errorCode)): \(error.localizedDescription)")
                }
            }
        }
    }
}

struct Archive: View {
    @State private var showPopupArchive = false
    @State private var isSpanish = false
    @State private var refreshCalendar = false
    
    var body: some View {
        VStack {
            Button(action: {
                showPopupArchive = true
            }) {
                Text(isSpanish ? "Archivar Evento" : "Archive Event")
                    .fontWeight(.bold)
                    .padding()
                    .background(Color.orange)
                    .foregroundColor(.white)
                    .cornerRadius(10)
            }
            .padding()
            
            if showPopupArchive {
                PopupView3(
                    showPopupArchive: $showPopupArchive,
                    isSpanish: $isSpanish,
                    onEventArchived: {
                        refreshCalendar = true
                    }
                )
            }
        }
    }
}

#Preview {
    Archive()
}
