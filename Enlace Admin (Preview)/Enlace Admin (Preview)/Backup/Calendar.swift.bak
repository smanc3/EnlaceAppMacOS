//
//  Calendar.swift
//  Enlace Admin (Preview)
//
//  Created by Steven Mancilla on 2/7/25.
//
import SwiftUI
import CloudKit
import PDFKit

// Model for calendar events
struct CalendarEvent: Identifiable {
    let id: CKRecord.ID
    let title: String
    let startDate: Date
    let endDate: Date?
    let location: String
    let notes: String?
    let pdfReference: CKRecord.Reference?
    let recordNameMirror: String
    
    init(record: CKRecord) {
        self.id = record.recordID
        self.title = record["title"] as? String ?? "Untitled Event"
        self.startDate = record["startDate"] as? Date ?? Date()
        self.endDate = record["endDate"] as? Date
        self.location = record["location"] as? String ?? ""
        self.notes = record["notes"] as? String
        self.pdfReference = record["pdfReference"] as? CKRecord.Reference
        self.recordNameMirror = record["recordNameMirror"] as? String ?? record.recordID.recordName
    }
}

struct CalendarView: View {
    @Binding var isSpanish: Bool  // Binding to control language selection
    @Binding var refreshTrigger: Bool  // Binding to trigger refresh when new events are created
    
    @State private var selectedDate = Date()
    @State private var currentMonthDate = Date()
    @State private var events: [CalendarEvent] = []
    @State private var isLoading: Bool = false
    @State private var errorMessage: String? = nil
    @State private var selectedDateEvents: [CalendarEvent] = []
    @State private var selectedEvent: CalendarEvent? = nil
    @State private var isEventDetailPresented: Bool = false
    
    private let container = CKContainer(identifier: "iCloud.PearInc.EICT-iOS-16")
    private var database: CKDatabase {
        return container.publicCloudDatabase
    }
    
    private var daysOfWeek: [String] {
        let formatter = DateFormatter()
        formatter.locale = Locale(identifier: isSpanish ? "es_ES" : "en_US")
        return formatter.veryShortWeekdaySymbols
    }
    
    private var currentMonth: [Date] {
        let calendar = Calendar.current
        let range = calendar.range(of: .day, in: .month, for: currentMonthDate)!
        let firstDayOfMonth = calendar.date(from: calendar.dateComponents([.year, .month], from: currentMonthDate))!
        
        var days: [Date] = []
        
        // Add leading empty days before the first day of the month
        let firstWeekday = calendar.component(.weekday, from: firstDayOfMonth) - 1
        for _ in 0..<firstWeekday {
            days.append(Date.distantPast)  // Dummy date for empty space
        }
        
        // Add the actual days of the month
        for day in range {
            if let dayDate = calendar.date(byAdding: .day, value: day - 1, to: firstDayOfMonth) {
                days.append(dayDate)
            }
        }
        
        return days
    }
    
    private func isSelected(date: Date) -> Bool {
        let calendar = Calendar.current
        return calendar.isDate(date, inSameDayAs: selectedDate)
    }
    
    private func hasEvent(date: Date) -> Bool {
        let calendar = Calendar.current
        return events.contains { event in
            calendar.isDate(event.startDate, inSameDayAs: date)
        }
    }
    
    private func monthYearString(date: Date) -> String {
        let formatter = DateFormatter()
        formatter.locale = Locale(identifier: isSpanish ? "es_ES" : "en_US")
        formatter.dateFormat = "MMMM yyyy"
        return formatter.string(from: date).capitalized
    }
    
    private func goToNextMonth() {
        currentMonthDate = Calendar.current.date(byAdding: .month, value: 1, to: currentMonthDate) ?? currentMonthDate
    }
    
    private func goToPreviousMonth() {
        currentMonthDate = Calendar.current.date(byAdding: .month, value: -1, to: currentMonthDate) ?? currentMonthDate
    }
    
    private func updateSelectedDateEvents() {
        let calendar = Calendar.current
        selectedDateEvents = events.filter { event in
            calendar.isDate(event.startDate, inSameDayAs: selectedDate)
        }
    }
    
    var body: some View {
        VStack {
            ZStack {
                Color.white
                    .cornerRadius(20)
                    .shadow(radius: 10)
                    .frame(maxWidth: .infinity, maxHeight: .infinity)
                
                VStack(spacing: 10) {
                    // Month Header Section
                    HStack {
                        Button(action: goToPreviousMonth) {
                            Image(systemName: "chevron.left")
                                .font(.title)
                                .foregroundColor(.orange)
                        }
                        
                        Spacer()
                        
                        Text(monthYearString(date: currentMonthDate))
                            .font(.title)
                            .bold()
                            .foregroundColor(.orange)
                        
                        Spacer()
                        
                        // Add refresh button
                        Button(action: loadEvents) {
                            Image(systemName: "arrow.clockwise")
                                .font(.title2)
                                .foregroundColor(.orange)
                        }
                        .padding(.trailing, 5)
                        
                        Button(action: goToNextMonth) {
                            Image(systemName: "chevron.right")
                                .font(.title)
                                .foregroundColor(.orange)
                        }
                    }
                    .padding([.horizontal, .top])
                    
                    Divider()
                    
                    // Weekday Row Section
                    HStack {
                        ForEach(daysOfWeek, id: \.self) { day in
                            Text(day.prefix(1))
                                .font(.headline)
                                .foregroundColor(.orange)
                                .frame(maxWidth: .infinity)
                        }
                    }
                    .padding(.vertical, 6)
                    
                    Divider()
                    
                    // Calendar Days Grid Section
                    LazyVGrid(columns: Array(repeating: GridItem(.flexible()), count: 7), spacing: 10) {
                        ForEach(currentMonth, id: \.self) { date in
                            if date == Date.distantPast {
                                Rectangle()
                                    .foregroundColor(.clear)
                                    .frame(height: 30)
                            } else {
                                Text("\(Calendar.current.component(.day, from: date))")
                                    .frame(width: 30, height: 30)
                                    .background(isSelected(date: date) ? Color.orange : Color.clear)
                                    .cornerRadius(15)
                                    .overlay(
                                        Circle()
                                            .fill(Color.blue)
                                            .frame(width: 5, height: 5)
                                            .offset(y: 10)
                                            .opacity(hasEvent(date: date) ? 1 : 0)
                                    )
                                    .onTapGesture {
                                        selectedDate = date
                                        updateSelectedDateEvents()
                                    }
                                    .foregroundColor(isSelected(date: date) ? Color.white : Color.black)
                            }
                        }
                    }
                    .padding(.horizontal, 5)
                    
                    Divider()
                    
                    // Events for selected date
                    VStack(alignment: .leading) {
                        Text(isSpanish ? "Eventos para \(selectedDate, style: .date)" : "Events for \(selectedDate, style: .date)")
                            .font(.headline)
                            .padding(.bottom, 5)
                        
                        if selectedDateEvents.isEmpty {
                            Text(isSpanish ? "No hay eventos programados" : "No events scheduled")
                                .font(.subheadline)
                                .foregroundColor(.secondary)
                        } else {
                            ScrollView {
                                ForEach(selectedDateEvents) { event in
                                    EventListItemView(
                                        event: event,
                                        onTap: {
                                            selectedEvent = event
                                            isEventDetailPresented = true
                                        }
                                    )
                                }
                            }
                            .frame(minHeight: 150, maxHeight: .infinity)
                        }
                    }
                    .padding(.horizontal)
                    .padding(.top, 5)
                    
                    Spacer()
                }
                .padding()
            }
            .frame(maxWidth: .infinity, maxHeight: .infinity)
            .padding()
        }
        .background(Color(.gray))
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .onAppear {
            loadEvents()
        }
        .onChange(of: refreshTrigger) { oldValue, newValue in
            if newValue {
                loadEvents()
                refreshTrigger = false  // Reset the trigger after refreshing
            }
        }
        .sheet(isPresented: $isEventDetailPresented) {
            if let event = selectedEvent {
                EventDetailView(event: event, isSpanish: isSpanish, container: container)
            }
        }
    }
    
    private func loadEvents() {
        isLoading = true
        
        let query = CKQuery(recordType: "CalendarEvent", predicate: NSPredicate(value: true))
        query.sortDescriptors = [NSSortDescriptor(key: "startDate", ascending: true)]
        
        database.fetch(withQuery: query, inZoneWith: nil, desiredKeys: nil, resultsLimit: 50) { result in
            DispatchQueue.main.async {
                self.isLoading = false
                
                switch result {
                case .success(let matchResults):
                    let records = matchResults.matchResults.compactMap { (recordID, recordResult) -> CKRecord? in
                        if case .success(let record) = recordResult {
                            // Ensure recordNameMirror is set
                            if record["recordNameMirror"] == nil {
                                record["recordNameMirror"] = record.recordID.recordName
                                
                                // Save the updated record with recordNameMirror in the background
                                DispatchQueue.global(qos: .background).async {
                                    self.database.save(record) { _, error in
                                        if let error = error {
                                            print("Error updating recordNameMirror: \(error.localizedDescription)")
                                        }
                                    }
                                }
                            }
                            return record
                        }
                        return nil
                    }
                    
                    // Debug info
                    print("Calendar: Found \(records.count) records")
                    for record in records {
                        print("Calendar record: \(record.recordID.recordName), title: \(record["title"] ?? "No title")")
                    }
                    
                    self.events = records.map { CalendarEvent(record: $0) }
                    self.updateSelectedDateEvents()
                    
                case .failure(let error):
                    print("Calendar error: \(error.localizedDescription)")
                    self.errorMessage = error.localizedDescription
                }
            }
        }
    }
}

// Detail view for an event
struct EventDetailView: View {
    let event: CalendarEvent
    let isSpanish: Bool
    let container: CKContainer
    
    @State private var linkedPDF: PDFKit.PDFDocument? = nil
    @State private var isLoadingPDF: Bool = false
    @State private var pdfError: String? = nil
    
    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 15) {
                // Title
                Text(event.title)
                    .font(.title)
                    .fontWeight(.bold)
                
                // Date and Time
                HStack {
                    Image(systemName: "calendar")
                        .foregroundColor(.orange)
                    
                    VStack(alignment: .leading) {
                        Text(DateFormatter.localizedString(from: event.startDate, dateStyle: .full, timeStyle: .none))
                            .fontWeight(.medium)
                        
                        HStack {
                            Text(DateFormatter.localizedString(from: event.startDate, dateStyle: .none, timeStyle: .short))
                            
                            if let endDate = event.endDate {
                                Text(" - \(DateFormatter.localizedString(from: endDate, dateStyle: .none, timeStyle: .short))")
                            }
                        }
                    }
                }
                
                // Location
                HStack {
                    Image(systemName: "mappin.and.ellipse")
                        .foregroundColor(.red)
                    
                    Text(event.location)
                        .fontWeight(.medium)
                }
                
                // Notes
                if let notes = event.notes, !notes.isEmpty {
                    Divider()
                    
                    Text(isSpanish ? "Notas:" : "Notes:")
                        .font(.headline)
                    
                    Text(notes)
                        .padding()
                        .background(Color(NSColor.controlBackgroundColor))
                        .cornerRadius(8)
                }
                
                // Linked PDF
                if event.pdfReference != nil {
                    Divider()
                    
                    Text(isSpanish ? "Documento adjunto:" : "Attached Document:")
                        .font(.headline)
                    
                    if isLoadingPDF {
                        ProgressView()
                            .padding()
                    } else if let error = pdfError {
                        Text(error)
                            .foregroundColor(.red)
                            .padding()
                    } else if let pdf = linkedPDF {
                        PDFPreview(document: pdf)
                            .frame(height: 400)
                            .cornerRadius(8)
                    } else {
                        Button(action: loadLinkedPDF) {
                            Label(isSpanish ? "Cargar PDF" : "Load PDF", systemImage: "doc.text")
                        }
                        .buttonStyle(.bordered)
                        .padding()
                    }
                }
            }
            .padding()
        }
        .navigationTitle(isSpanish ? "Detalles del Evento" : "Event Details")
        .onAppear {
            if event.pdfReference != nil {
                loadLinkedPDF()
            }
        }
    }
    
    private func loadLinkedPDF() {
        guard let reference = event.pdfReference else { return }
        isLoadingPDF = true
        
        let database = container.publicCloudDatabase
        database.fetch(withRecordID: reference.recordID) { record, error in
            DispatchQueue.main.async {
                isLoadingPDF = false
                
                if let error = error {
                    pdfError = isSpanish ? 
                        "Error al cargar PDF: \(error.localizedDescription)" : 
                        "Error loading PDF: \(error.localizedDescription)"
                } else if let record = record, 
                          let asset = record["pdfFile"] as? CKAsset,
                          let fileURL = asset.fileURL,
                          let document = PDFKit.PDFDocument(url: fileURL) {
                    linkedPDF = document
                } else {
                    pdfError = isSpanish ? 
                        "No se pudo cargar el PDF" : 
                        "Could not load the PDF"
                }
            }
        }
    }
}

// PDF Preview
struct PDFPreview: NSViewRepresentable {
    let document: PDFKit.PDFDocument
    
    func makeNSView(context: NSViewRepresentableContext<PDFPreview>) -> PDFView {
        let view = PDFView()
        view.document = document
        view.autoScales = true
        return view
    }
    
    func updateNSView(_ nsView: PDFView, context: NSViewRepresentableContext<PDFPreview>) {
        nsView.document = document
    }
}

// Helper view to simplify the event list item
struct EventListItemView: View {
    let event: CalendarEvent
    let onTap: () -> Void
    
    var body: some View {
        HStack {
            VStack(alignment: .leading) {
                // Title
                Text(event.title)
                    .font(.headline)
                
                // Location
                Text(event.location)
                    .font(.subheadline)
                
                // Time range
                HStack {
                    Text(DateFormatter.localizedString(from: event.startDate, dateStyle: .none, timeStyle: .short))
                    
                    if let endDate = event.endDate {
                        Text(" - \(DateFormatter.localizedString(from: endDate, dateStyle: .none, timeStyle: .short))")
                    }
                }
                .font(.caption)
                .foregroundColor(.secondary)
                
                // Icons for notes and PDF
                if event.notes != nil || event.pdfReference != nil {
                    HStack {
                        if event.notes != nil {
                            Image(systemName: "note.text")
                        }
                        
                        if event.pdfReference != nil {
                            Image(systemName: "doc.text")
                        }
                    }
                    .font(.caption)
                    .foregroundColor(.blue)
                }
            }
            
            Spacer()
        }
        .padding(.vertical, 5)
        .padding(.horizontal)
        .background(Color(NSColor.controlBackgroundColor))
        .cornerRadius(8)
        .padding(.horizontal, 5)
        .padding(.bottom, 5)
        .contentShape(Rectangle())
        .onTapGesture(perform: onTap)
    }
}

struct CalendarView_Previews: PreviewProvider {
    static var previews: some View {
        CalendarView(isSpanish: .constant(false), refreshTrigger: .constant(false))
    }
}
