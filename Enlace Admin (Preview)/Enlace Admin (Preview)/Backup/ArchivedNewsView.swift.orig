//
//  ArchivedNewsView.swift
//  Enlace Admin (Preview)
//
//  Created on 4/21/25.
//

import SwiftUI
import CloudKit
import PDFKit

// Use the ArchivedNewsPost from NewsFeedManagementView.swift
// typealias ArchivedNewsPost = Enlace_Admin__Preview_.ArchivedNewsPost

// MARK: - Archived News View
struct ArchivedNewsView: View {
    @Binding var isSpanish: Bool
    @Binding var refreshTrigger: Bool
    
    @State private var archivedPosts: [ModelsArchivedNewsPost] = []
    @State private var isLoading: Bool = true
    @State private var errorMessage: String? = nil
    @State private var searchText: String = ""
    @State private var selectedPost: ModelsArchivedNewsPost? = nil
    @State private var showPostDetail: Bool = false
    @State private var sortOption: SortOption = .dateArchived
    @State private var showDeleteConfirmation: Bool = false
    @State private var showUnarchiveConfirmation: Bool = false
    @State private var postToDelete: ModelsArchivedNewsPost? = nil
    @State private var postToUnarchive: ModelsArchivedNewsPost? = nil
    
    private let container = CKContainer(identifier: "iCloud.PearInc.EICT-iOS-16")
    private var database: CKDatabase {
        return container.publicCloudDatabase
    }
    
    enum SortOption {
        case dateArchived, datePosted, title
        
        var localizedName: String {
            switch self {
            case .dateArchived: return "Archive Date"
            case .datePosted: return "Post Date"
            case .title: return "Title"
            }
        }
        
        var localizedNameSpanish: String {
            switch self {
            case .dateArchived: return "Fecha de Archivo"
            case .datePosted: return "Fecha de Publicación"
            case .title: return "Título"
            }
        }
    }
    
    private var filteredPosts: [ModelsArchivedNewsPost] {
        var result = archivedPosts
        
        // Apply search filtering
        if !searchText.isEmpty {
            result = result.filter { post in
                post.title.localizedCaseInsensitiveContains(searchText)
            }
        }
        
        // Apply sorting
        switch sortOption {
        case .dateArchived:
            result.sort { $0.archivedDate > $1.archivedDate }
        case .datePosted:
            result.sort { $0.datePosted > $1.datePosted }
        case .title:
            result.sort { $0.title < $1.title }
        }
        
        return result
    }
    
    var body: some View {
        VStack(spacing: 0) {
            // Header
            HStack {
                Text(isSpanish ? "Noticias Archivadas" : "Archived News")
                    .font(.title)
                    .fontWeight(.bold)
                
                Spacer()
                
                // Refresh button
                Button(action: loadArchivedPosts) {
                    Label(isSpanish ? "Actualizar" : "Refresh", systemImage: "arrow.clockwise")
                }
                .buttonStyle(.bordered)
            }
            
            // Search and sort options
            HStack {
                // Search field
                HStack {
                    Image(systemName: "magnifyingglass")
                        .foregroundColor(.secondary)
                    TextField(isSpanish ? "Buscar por título..." : "Search by title...", text: $searchText)
                    
                    if !searchText.isEmpty {
                        Button(action: {
                            searchText = ""
                        }) {
                            Image(systemName: "xmark.circle.fill")
                                .foregroundColor(.secondary)
                        }
                        .buttonStyle(.plain)
                    }
                }
                .padding(8)
                .background(Color(NSColor.controlBackgroundColor))
                .cornerRadius(8)
                
                // Sort menu
                Menu {
                    Button(action: { sortOption = .dateArchived }) {
                        Label(isSpanish ? "Fecha de Archivo" : "Archive Date", systemImage: "calendar")
                    }
                    
                    Button(action: { sortOption = .datePosted }) {
                        Label(isSpanish ? "Fecha de Publicación" : "Post Date", systemImage: "calendar.badge.clock")
                    }
                    
                    Button(action: { sortOption = .title }) {
                        Label(isSpanish ? "Título" : "Title", systemImage: "textformat")
                    }
                } label: {
                    Label(
                        isSpanish ? "Ordenar: \(sortOption.localizedNameSpanish)" : "Sort: \(sortOption.localizedName)",
                        systemImage: "arrow.up.arrow.down"
                    )
                }
                .menuStyle(.button)
            }
            .padding(.horizontal)
            .padding(.vertical, 8)
            .background(Color(NSColor.textBackgroundColor))
            
            if isLoading {
                // Loading indicator
                VStack {
                    Spacer()
                    ProgressView()
                        .scaleEffect(1.5)
                    Text(isSpanish ? "Cargando noticias archivadas..." : "Loading archived news...")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                        .padding()
                    Spacer()
                }
            } else if let error = errorMessage {
                // Error message
                VStack {
                    Spacer()
                    Image(systemName: "exclamationmark.triangle")
                        .font(.system(size: 40))
                        .foregroundColor(.orange)
                        .padding()
                    
                    Text(error)
                        .multilineTextAlignment(.center)
                        .padding()
                    
                    Button(isSpanish ? "Intentar de nuevo" : "Try Again") {
                        loadArchivedPosts()
                    }
                    .buttonStyle(.bordered)
                    .padding()
                    
                    Spacer()
                }
            } else if filteredPosts.isEmpty {
                // Empty state
                VStack {
                    Spacer()
                    
                    Image(systemName: "archivebox")
                        .font(.system(size: 40))
                        .foregroundColor(.gray)
                        .padding()
                    
                    Text(isSpanish ? "No hay noticias archivadas" : "No archived news")
                        .font(.headline)
                    
                    if !searchText.isEmpty {
                        Text(isSpanish ? "Prueba con diferentes términos de búsqueda" : "Try different search terms")
                            .font(.subheadline)
                            .foregroundColor(.secondary)
                            .padding(.top, 5)
                    }
                    
                    Spacer()
                }
            } else {
                // Post list
                List {
                    ForEach(filteredPosts) { post in
                        ArchivedNewsPostRow(
                            post: post, 
                            isSpanish: isSpanish,
                            onDelete: { post in
                                postToDelete = post
                                showDeleteConfirmation = true
                            },
                            onUnarchive: { post in
                                postToUnarchive = post
                                showUnarchiveConfirmation = true
                            }
                        )
                        .contentShape(Rectangle())
                        .onTapGesture {
                            selectedPost = post
                            showPostDetail = true
                        }
                    }
                }
                .listStyle(.inset)
            }
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .onAppear {
            loadArchivedPosts()
            
            // Add notification observer when the view appears
            NotificationCenter.default.addObserver(
                forName: Notification.Name("ArchivedNewsPostNotification"),
                object: nil,
                queue: .main
            ) { _ in
                print("📰 ArchivedNews: Received notification of newly archived post, refreshing...")
                loadArchivedPosts()
            }
        }
        .onDisappear {
            // Remove the observer when the view disappears
            NotificationCenter.default.removeObserver(
                self,
                name: Notification.Name("ArchivedNewsPostNotification"),
                object: nil
            )
        }
        .onChange(of: refreshTrigger) { oldValue, newValue in
            if newValue {
                loadArchivedPosts()
                refreshTrigger = false
            }
        }
        .sheet(isPresented: $showPostDetail) {
            if let post = selectedPost {
                ArchivedNewsDetailView(
                    post: post, 
                    isSpanish: isSpanish, 
                    container: container,
                    onDelete: { post in
                        postToDelete = post
                        showDeleteConfirmation = true
                    },
                    onUnarchive: { post in
                        postToUnarchive = post
                        showUnarchiveConfirmation = true
                    }
                )
                .frame(width: 600, height: 500)
            }
        }
        .alert(isSpanish ? "¿Eliminar este post?" : "Delete this post?", isPresented: $showDeleteConfirmation) {
            Button(isSpanish ? "Eliminar" : "Delete", role: .destructive) {
                if let post = postToDelete {
                    deleteArchivedPost(post)
                    if selectedPost?.id == post.id {
                        selectedPost = nil
                        showPostDetail = false
                    }
                }
            }
            Button(isSpanish ? "Cancelar" : "Cancel", role: .cancel) {}
        } message: {
            Text(isSpanish ? "Esta acción no se puede deshacer." : "This action cannot be undone.")
        }
        .alert(isSpanish ? "¿Desarchivar este post?" : "Unarchive this post?", isPresented: $showUnarchiveConfirmation) {
            Button(isSpanish ? "Desarchivar" : "Unarchive", role: .none) {
                if let post = postToUnarchive {
                    unarchivePost(post)
                    if selectedPost?.id == post.id {
                        selectedPost = nil
                        showPostDetail = false
                    }
                }
            }
            Button(isSpanish ? "Cancelar" : "Cancel", role: .cancel) {}
        } message: {
            Text(isSpanish ? "Este post volverá a aparecer en la lista principal de noticias." : "This post will be moved back to the main news feed.")
        }
    }
    
    private func loadArchivedPosts() {
        isLoading = true
        errorMessage = nil
        
        print("📰 ArchivedNews: Starting to load archived news posts")
        
        let database = CKContainer(identifier: "iCloud.PearInc.EICT-iOS-16").publicCloudDatabase
        
        print("📰 ArchivedNews: Using direct fetch approach to avoid query issues")
        
        Task {
            do {
                // Get record zones first - this should work without query issues
                let zones = try await database.allRecordZones()
                print("📰 ArchivedNews: Successfully retrieved \(zones.count) record zones")
                
                // If there's a default zone, use that
                guard let defaultZone = zones.first(where: { $0.zoneID.zoneName == "_defaultZone" }) ?? zones.first else {
                    throw NSError(domain: "ArchivedNewsError", code: 1, userInfo: [NSLocalizedDescriptionKey: "No zones found"])
                }
                
                print("📰 ArchivedNews: Attempting direct fetch operation (no query)")
                
                // Create an operation to fetch all records
                let configuration = CKOperation.Configuration()
                configuration.timeoutIntervalForRequest = 30
                
                let fetchOperation = CKFetchRecordZoneChangesOperation(recordZoneIDs: [defaultZone.zoneID], configurationsByRecordZoneID: [:])
                fetchOperation.configuration = configuration
                
                var fetchedRecords: [CKRecord] = []
                
                // Set up completion handlers
                fetchOperation.recordWasChangedBlock = { (recordID, result) in
                    switch result {
                    case .success(let record):
                        if record.recordType == "ArchivedNewsPost" {
                            fetchedRecords.append(record)
                            print("📰 ArchivedNews: Found ArchivedNewsPost record: \(record.recordID.recordName)")
                        }
                    case .failure(let error):
                        print("📰 ArchivedNews: Error with record: \(error.localizedDescription)")
                    }
                }
                
                fetchOperation.recordZoneFetchResultBlock = { zoneID, result in
                    switch result {
                    case .success(let changeToken):
                        print("📰 ArchivedNews: Successfully fetched zone \(zoneID.zoneName), more changes coming: \(changeToken.moreComing)")
                    case .failure(let error):
                        print("📰 ArchivedNews: Error fetching zone \(zoneID.zoneName): \(error.localizedDescription)")
                    }
                }
                
                // Use a continuation to handle the final result
                _ = await withCheckedContinuation { continuation in
                    fetchOperation.fetchRecordZoneChangesResultBlock = { result in
                        switch result {
                        case .success:
                            print("📰 ArchivedNews: Operation completed successfully")
                        case .failure(let error):
                            print("📰 ArchivedNews: Operation failed: \(error.localizedDescription)")
                        }
                        continuation.resume(returning: ())
                    }
                    
                    // Add operation to database
                    database.add(fetchOperation)
                }
                
                // Process the fetched records
                print("📰 ArchivedNews: Retrieved \(fetchedRecords.count) ArchivedNewsPost records")
                
                if fetchedRecords.isEmpty {
                    // Fallback to a direct CloudKit fetch with a small batch size
                    print("📰 ArchivedNews: No records found with zone changes operation, trying fallback method")
                    let fallbackRecords = try await fetchArchivedNewsWithFallback(database: database)
                    fetchedRecords = fallbackRecords
                }
                
                var recordsWithMissingMirror: [CKRecord] = []
                
                // Process the records
                for record in fetchedRecords {
                    if record["recordNameMirror"] == nil {
                        record["recordNameMirror"] = record.recordID.recordName
                        recordsWithMissingMirror.append(record)
                    }
                }
                
                // Save the updated records
                for record in recordsWithMissingMirror {
                    Task {
                        do {
                            let _ = try await database.save(record)
                            print("📰 ArchivedNews: Updated record with missing recordNameMirror")
                        } catch {
                            print("📰 ArchivedNews: Failed to update recordNameMirror: \(error.localizedDescription)")
                        }
                    }
                }
                
                // Sort the records by archivedDate
                let sortedRecords = fetchedRecords.sorted {
                    let date1 = $0["archivedDate"] as? Date ?? Date()
                    let date2 = $1["archivedDate"] as? Date ?? Date()
                    return date1 > date2 // Newest first
                }
                
                // Create the ArchivedNewsPost array
                var posts = sortedRecords.map { ArchivedNewsPost(record: $0) }
                
                // Fetch PDF references
                let group = DispatchGroup()
                
                for i in 0..<posts.count {
                    if let pdfRef = posts[i].pdfReference {
                        group.enter()
                        
                        Task {
                            do {
                                let record = try await database.record(for: pdfRef.recordID)
                                let pdfDetails = PDFDocumentDetails(record: record)
                                
                                DispatchQueue.main.async {
                                    // Safely update the post with PDF details
                                    if i < posts.count {
                                        posts[i].pdfDocument = pdfDetails
                                    }
                                }
                            } catch {
                                print("📰 ArchivedNews: Failed to fetch PDF: \(error.localizedDescription)")
                            }
                            
                            group.leave()
                        }
                    }
                }
                
                // Update UI when all PDFs are fetched
                group.notify(queue: .main) {
                    self.archivedPosts = posts
                    self.isLoading = false
                    print("📰 ArchivedNews: Mapped \(posts.count) records to ArchivedNewsPost objects")
                }
                
            } catch {
                DispatchQueue.main.async {
                    self.isLoading = false
                    
                    if let ckError = error as? CKError {
                        print("📰 ArchivedNews: CloudKit error: \(ckError.localizedDescription)")
                        print("📰 ArchivedNews: Error code: \(ckError.errorCode)")
                        if let errorInfo = ckError.userInfo["NSDebugDescription"] as? String {
                            print("📰 ArchivedNews: Debug description: \(errorInfo)")
                        }
                        
                        self.errorMessage = isSpanish ? 
                            "Error al cargar noticias archivadas: \(ckError.localizedDescription)" : 
                            "Error loading archived news: \(ckError.localizedDescription)"
                    } else {
                        print("📰 ArchivedNews: Unknown error: \(error.localizedDescription)")
                        self.errorMessage = isSpanish ? 
                            "Error al cargar noticias archivadas: \(error.localizedDescription)" : 
                            "Error loading archived news: \(error.localizedDescription)"
                    }
                }
            }
        }
    }
    
    // Fallback method for fetching archived news without a query
    private func fetchArchivedNewsWithFallback(database: CKDatabase) async throws -> [CKRecord] {
        print("📰 ArchivedNews: Using fallback method to fetch posts")
        
        // Create a fetch records operation with an empty array
        var records: [CKRecord] = []
        
        // First try a direct query using archivedDate
        print("📰 ArchivedNews: Using date-based query strategy")
        
        // Create a very wide date range to capture all events
        let distantPast = Date.distantPast
        let distantFuture = Date.distantFuture
        
        // Create a query that filters on archivedDate (which is now properly queryable in the schema)
        let datePredicate = NSPredicate(format: "archivedDate >= %@ AND archivedDate <= %@", distantPast as NSDate, distantFuture as NSDate)
        let query = CKQuery(recordType: "ArchivedNewsPost", predicate: datePredicate)
        query.sortDescriptors = [NSSortDescriptor(key: "archivedDate", ascending: false)]
        
        // Try to fetch records directly using the records(matching:) API
        do {
            print("📰 ArchivedNews: Executing date-based query from \(distantPast) to \(distantFuture)")
            let (matchResults, _) = try await database.records(matching: query)
            
            // Process results directly
            for (_, recordResult) in matchResults {
                switch recordResult {
                case .success(let record):
                    records.append(record)
                    print("📰 ArchivedNews: Successfully found record: \(record.recordID.recordName), title: \(record["title"] ?? "nil")")
                case .failure(let error):
                    print("📰 ArchivedNews: Error loading record: \(error.localizedDescription)")
                }
            }
            
            print("📰 ArchivedNews: Successfully loaded \(records.count) records directly")
        } catch {
            print("📰 ArchivedNews: Query failed with error: \(error.localizedDescription)")
            
            // If the date-based query fails, try a simple predicate
            print("📰 ArchivedNews: Trying simple predicate as last resort")
            do {
                let simpleQuery = CKQuery(recordType: "ArchivedNewsPost", predicate: NSPredicate(value: true))
                let (simpleResults, _) = try await database.records(matching: simpleQuery)
                
                for (_, recordResult) in simpleResults {
                    if case .success(let record) = recordResult {
                        records.append(record)
                        print("📰 ArchivedNews: Found record with simple query: \(record.recordID.recordName)")
                    }
                }
                print("📰 ArchivedNews: Simple query found \(records.count) records")
            } catch {
                print("📰 ArchivedNews: Simple query also failed: \(error.localizedDescription)")
                if let ckError = error as? CKError {
                    print("📰 ArchivedNews: CloudKit error code: \(ckError.errorCode)")
                    if let serverDesc = ckError.userInfo["ServerErrorDescription"] as? String {
                        print("📰 ArchivedNews: Server error description: \(serverDesc)")
                    }
                }
            }
        }
        
        return records
    }
    
    private func deleteArchivedPost(_ post: ModelsArchivedNewsPost) {
        print("📰 ArchivedNews: Deleting archived post: \(post.id.recordName)")
        isLoading = true
        
        // First, check if there's a PDF reference and clear the isArchived flag
        if let pdfRef = post.pdfReference {
            database.fetch(withRecordID: pdfRef.recordID) { pdfRecord, error in
                if let pdfRecord = pdfRecord, error == nil {
                    // Remove the isArchived flag
                    pdfRecord["isArchived"] = nil
                    
                    print("📰 ArchivedNews: Clearing isArchived flag from PDF before deleting")
                    self.database.save(pdfRecord) { _, error in
                        if let error = error {
                            print("📰 ArchivedNews: Warning - Failed to remove archived flag from PDF: \(error.localizedDescription)")
                        } else {
                            print("📰 ArchivedNews: Successfully removed archived flag from PDF")
                        }
                    }
                }
            }
        }
        
        // Now delete the archived post record
        database.delete(withRecordID: post.id) { _, error in
            DispatchQueue.main.async {
                isLoading = false
                
                if let error = error {
                    print("📰 ArchivedNews: Error deleting archived post: \(error.localizedDescription)")
                    errorMessage = isSpanish ?
                        "Error al eliminar: \(error.localizedDescription)" :
                        "Error deleting: \(error.localizedDescription)"
                } else {
                    print("📰 ArchivedNews: Successfully deleted archived post")
                    // Remove the post from the local array
                    archivedPosts.removeAll { $0.id == post.id }
                    
                    // Notify the news feed to refresh
                    NotificationCenter.default.post(name: Notification.Name("NewsFeedRefreshNotification"), object: nil)
                }
            }
        }
    }
    
    private func unarchivePost(_ post: ModelsArchivedNewsPost) {
        print("📰 ArchivedNews: Unarchiving post: \(post.id.recordName)")
        isLoading = true
        
        // Step 1: Create a new news feed item
        let newsFeedItem = CKRecord(recordType: "NewsFeedItem")
        
        // Copy data from the archived post
        newsFeedItem["title"] = post.title
        newsFeedItem["datePosted"] = post.datePosted
        newsFeedItem["recordNameMirror"] = post.recordNameMirror
        
        // Add PDF reference if available
        if let pdfRef = post.pdfReference {
            newsFeedItem["pdfReference"] = pdfRef
            
            // Update the PDF to remove the archived flag
            database.fetch(withRecordID: pdfRef.recordID) { pdfRecord, error in
                if let pdfRecord = pdfRecord, error == nil {
                    // Remove the isArchived flag
                    pdfRecord["isArchived"] = nil
                    
                    database.save(pdfRecord) { _, error in
                        if let error = error {
                            print("📰 ArchivedNews: Warning - Failed to remove archived flag from PDF: \(error.localizedDescription)")
                        } else {
                            print("📰 ArchivedNews: Successfully removed archived flag from PDF")
                        }
                    }
                }
            }
        }
        
        // Step 2: Save the new news feed item
        database.save(newsFeedItem) { _, error in
            if let error = error {
                DispatchQueue.main.async {
                    isLoading = false
                    print("📰 ArchivedNews: Error creating new news feed item: \(error.localizedDescription)")
                    errorMessage = isSpanish ?
                        "Error al desarchivar: \(error.localizedDescription)" :
                        "Error unarchiving: \(error.localizedDescription)"
                }
                return
            }
            
            print("📰 ArchivedNews: Successfully created new news feed item")
            
            // Step 3: Delete the archived post
            database.delete(withRecordID: post.id) { _, error in
                DispatchQueue.main.async {
                    isLoading = false
                    
                    if let error = error {
                        print("📰 ArchivedNews: Error deleting archived post during unarchive: \(error.localizedDescription)")
                        errorMessage = isSpanish ?
                            "Error al eliminar post archivado: \(error.localizedDescription)" :
                            "Error deleting archived post: \(error.localizedDescription)"
                    } else {
                        print("📰 ArchivedNews: Successfully unarchived post")
                        // Remove the post from the local array
                        archivedPosts.removeAll { $0.id == post.id }
                        
                        // Notify the news feed to refresh
                        NotificationCenter.default.post(name: Notification.Name("NewsFeedRefreshNotification"), object: nil)
                    }
                }
            }
        }
    }
}

// MARK: - Row for displaying an archived news post in the list
struct ArchivedNewsPostRow: View {
    let post: ModelsArchivedNewsPost
    let isSpanish: Bool
    var onDelete: ((ModelsArchivedNewsPost) -> Void)? = nil
    var onUnarchive: ((ModelsArchivedNewsPost) -> Void)? = nil
    
    private var dateFormatter: DateFormatter {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        formatter.timeStyle = .short
        return formatter
    }
    
    var body: some View {
        VStack(alignment: .leading, spacing: 5) {
            // Title and archived date
            HStack {
                Text(post.title)
                    .font(.headline)
                
                Spacer()
                
                Text(isSpanish ? "Archivado: " : "Archived: ")
                    .font(.caption)
                    .foregroundColor(.secondary)
                
                Text(dateFormatter.string(from: post.archivedDate))
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
            
            // Post date
            HStack {
                Image(systemName: "calendar")
                    .foregroundColor(.blue)
                    .font(.caption)
                
                Text(dateFormatter.string(from: post.datePosted))
                    .font(.caption)
            }
            
            // Indicators for PDF
            if post.pdfReference != nil {
                HStack {
                    Image(systemName: "doc.text")
                        .foregroundColor(.blue)
                        .font(.caption)
                    
                    Text(isSpanish ? "PDF adjunto" : "PDF attached")
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }
        }
        .padding(8)
        .background(Color(NSColor.controlBackgroundColor).opacity(0.5))
        .cornerRadius(8)
        .contextMenu {
            Button(action: {
                if let onUnarchive = onUnarchive {
                    onUnarchive(post)
                }
            }) {
                Label(isSpanish ? "Desarchivar" : "Unarchive", systemImage: "archivebox.fill.badge.plus")
            }
            
            Divider()
            
            Button(role: .destructive, action: {
                if let onDelete = onDelete {
                    onDelete(post)
                }
            }) {
                Label(isSpanish ? "Eliminar" : "Delete", systemImage: "trash")
            }
        }
    }
}

// MARK: - Detail view for an archived news post
struct ArchivedNewsDetailView: View {
    let post: ModelsArchivedNewsPost
    let isSpanish: Bool
    let container: CKContainer
    var onDelete: ((ModelsArchivedNewsPost) -> Void)? = nil
    var onUnarchive: ((ModelsArchivedNewsPost) -> Void)? = nil
    
    @State private var linkedPDF: PDFKit.PDFDocument? = nil
    @State private var isLoadingPDF: Bool = false
    @State private var pdfError: String? = nil
    @State private var pdfReadyForDisplay: Bool = false
    @Environment(\.presentationMode) var presentationMode
    @State private var showFullPDFView: Bool = false
    @State private var pdfRefreshTrigger: Bool = false
    @State private var pdfViewerKey: UUID = UUID()
    @State private var showDeleteConfirmation: Bool = false
    @State private var showUnarchiveConfirmation: Bool = false
    
    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 15) {
                // Title
                Text(post.title)
                    .font(.title)
                    .fontWeight(.bold)
                
                // Archived Date
                HStack {
                    Image(systemName: "archivebox")
                        .foregroundColor(.gray)
                    
                    Text(isSpanish ? "Archivado el " : "Archived on ")
                        .fontWeight(.medium)
                    
                    Text(DateFormatter.localizedString(from: post.archivedDate, dateStyle: .full, timeStyle: .short))
                        .fontWeight(.medium)
                }
                
                Divider()
                
                // Post Date
                HStack {
                    Image(systemName: "calendar")
                        .foregroundColor(.orange)
                    
                    Text(isSpanish ? "Publicado el " : "Posted on ")
                        .fontWeight(.medium)
                    
                    Text(DateFormatter.localizedString(from: post.datePosted, dateStyle: .full, timeStyle: .short))
                        .fontWeight(.medium)
                }
                
                // PDF if available
                if post.pdfReference != nil {
                    Divider()
                    
                    if isLoadingPDF {
                        HStack {
                            Spacer()
                            ProgressView()
                                .scaleEffect(1.0)
                            Text(isSpanish ? "Cargando PDF..." : "Loading PDF...")
                                .font(.caption)
                                .padding(.leading, 5)
                            Spacer()
                        }
                    } else if let error = pdfError {
                        HStack {
                            Image(systemName: "exclamationmark.triangle")
                                .foregroundColor(.orange)
                            
                            Text(error)
                                .foregroundColor(.secondary)
                                .font(.caption)
                        }
                    } else if let pdf = linkedPDF {
                        VStack(alignment: .leading) {
                            HStack {
                                Image(systemName: "doc.text.fill")
                                    .foregroundColor(.blue)
                                
                                Text(isSpanish ? "PDF Adjunto" : "Attached PDF")
                                    .fontWeight(.medium)
                                
                                Spacer()
                                
                                Button(isSpanish ? "Ver PDF Completo" : "View Full PDF") {
                                    loadAndShowPDF()
                                }
                                .buttonStyle(.bordered)
                            }
                            
                            // PDF preview
                            if pdf.pageCount > 0 {
                                PDFPreview(document: pdf)
                                    .frame(height: 200)
                                    .background(Color(NSColor.controlBackgroundColor))
                                    .cornerRadius(8)
                            } else {
                                Text(isSpanish ? "No se pueden mostrar páginas" : "Cannot display pages")
                                    .frame(height: 200)
                                    .frame(maxWidth: .infinity)
                                    .background(Color(NSColor.controlBackgroundColor))
                                    .cornerRadius(8)
                            }
                        }
                    } else {
                        HStack {
                            Image(systemName: "doc.text.fill")
                                .foregroundColor(.blue)
                            
                            Text(isSpanish ? "PDF Adjunto" : "Attached PDF")
                                .fontWeight(.medium)
                            
                            Spacer()
                            
                            Button(isSpanish ? "Cargar PDF" : "Load PDF") {
                                loadPDFWithCompletion {
                                    // No action needed after load
                                }
                            }
                            .buttonStyle(.bordered)
                        }
                    }
                }
                
                Spacer(minLength: 20)
                
                // Action buttons
                Divider()
                
                HStack {
                    Button(action: {
                        showUnarchiveConfirmation = true
                    }) {
                        Label(isSpanish ? "Desarchivar" : "Unarchive", systemImage: "archivebox.fill.badge.plus")
                            .frame(minWidth: 120)
                    }
                    .buttonStyle(.bordered)
                    
                    Spacer()
                    
                    Button(role: .destructive, action: {
                        showDeleteConfirmation = true
                    }) {
                        Label(isSpanish ? "Eliminar" : "Delete", systemImage: "trash")
                            .frame(minWidth: 120)
                    }
                    .buttonStyle(.borderedProminent)
                    .tint(.red)
                }
                .padding(.top, 8)
            }
            .padding()
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .onAppear {
            if post.pdfReference != nil {
                loadPDFWithCompletion {
                    // No action needed after initial load
                }
            }
        }
        .sheet(isPresented: $showFullPDFView) {
            if let pdf = linkedPDF, pdf.pageCount > 0 {
                ZStack {
                    Color(NSColor.windowBackgroundColor)
                        .edgesIgnoringSafeArea(.all)
                    
                    VStack(spacing: 0) {
                        // Header
                        HStack {
                            Text(isSpanish ? "PDF Completo: \(post.title)" : "Full PDF: \(post.title)")
                                .font(.headline)
                                
                            Spacer()
                                
                            Button(action: {
                                showFullPDFView = false
                            }) {
                                Text(isSpanish ? "Cerrar" : "Close")
                            }
                            .keyboardShortcut(.escape, modifiers: [])
                            .buttonStyle(.bordered)
                        }
                        .padding()
                        .background(Color(NSColor.windowBackgroundColor))
                        
                        // PDF viewer with explicit frame and refresh trigger
                        ArchivedNewsPDFViewer(document: pdf, refreshTrigger: $pdfRefreshTrigger)
                            .id(pdfViewerKey) // Force view recreation when key changes
                            .frame(minWidth: 800, minHeight: 600)
                            .frame(maxWidth: .infinity, maxHeight: .infinity)
                            .background(Color(NSColor.textBackgroundColor))
                    }
                }
                .frame(width: 1000, height: 800, alignment: .center)
                .onAppear {
                    // Force layout update and refresh
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                        if let window = NSApp.windows.first(where: { $0.isKeyWindow }) {
                            window.layoutIfNeeded()
                        }
                        pdfRefreshTrigger.toggle() // Trigger refresh
                        pdfViewerKey = UUID() // Force view recreation
                    }
                }
            } else {
                VStack {
                    Text(isSpanish ? "Error: No se pudo cargar el PDF" : "Error: Could not load PDF")
                        .foregroundColor(.red)
                    
                    Button(isSpanish ? "Cerrar" : "Close") {
                        showFullPDFView = false
                    }
                    .buttonStyle(.bordered)
                    .padding()
                }
                .padding()
            }
        }
        .onChange(of: linkedPDF) { oldValue, newValue in
            // When PDF document is loaded, mark it as ready for display
            if newValue != nil {
                pdfReadyForDisplay = true
            } else {
                pdfReadyForDisplay = false
            }
        }
        .alert(isSpanish ? "¿Eliminar este post?" : "Delete this post?", isPresented: $showDeleteConfirmation) {
            Button(isSpanish ? "Eliminar" : "Delete", role: .destructive) {
                if let onDelete = onDelete {
                    onDelete(post)
                    presentationMode.wrappedValue.dismiss()
                }
            }
            Button(isSpanish ? "Cancelar" : "Cancel", role: .cancel) {}
        } message: {
            Text(isSpanish ? "Esta acción no se puede deshacer." : "This action cannot be undone.")
        }
        .alert(isSpanish ? "¿Desarchivar este post?" : "Unarchive this post?", isPresented: $showUnarchiveConfirmation) {
            Button(isSpanish ? "Desarchivar" : "Unarchive", role: .none) {
                if let onUnarchive = onUnarchive {
                    onUnarchive(post)
                    presentationMode.wrappedValue.dismiss()
                }
            }
            Button(isSpanish ? "Cancelar" : "Cancel", role: .cancel) {}
        } message: {
            Text(isSpanish ? "Este post volverá a aparecer en la lista principal de noticias." : "This post will be moved back to the main news feed.")
        }
    }
    
    // Update loadAndShowPDF function
    private func loadAndShowPDF() {
        // Clear previous state
        linkedPDF = nil
        pdfError = nil
        isLoadingPDF = true
        pdfReadyForDisplay = false
        pdfViewerKey = UUID() // Reset viewer key
        
        // Load PDF with completion handler
        loadPDFWithCompletion {
            if let doc = linkedPDF, doc.pageCount > 0 {
                // Small delay to ensure UI state is updated
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                    pdfReadyForDisplay = true
                    showFullPDFView = true
                    pdfRefreshTrigger.toggle() // Trigger refresh
                    pdfViewerKey = UUID() // Force view recreation
                }
            } else {
                DispatchQueue.main.async {
                    pdfError = isSpanish ? 
                        "Error: No se pudo cargar el PDF correctamente" : 
                        "Error: Could not load the PDF properly"
                }
            }
        }
    }
    
    // Update loadPDFWithCompletion with enhanced debugging
    private func loadPDFWithCompletion(_ completion: @escaping () -> Void) {
        let startTime = Date()
        print("📋 PDF LOADING: Started at \(startTime.formatted(date: .omitted, time: .standard))")
        
        guard let reference = post.pdfReference else {
            pdfError = isSpanish ? "No hay referencia de PDF disponible" : "No PDF reference available"
            print("❌ PDF LOADING: Error - No PDF reference available")
            completion()
            return
        }
        
        print("📋 PDF LOADING: PDF reference ID: \(reference.recordID.recordName)")
        
        // Clear previous PDF document
        self.linkedPDF = nil
        isLoadingPDF = true
        pdfError = nil
        pdfReadyForDisplay = false
        
        Task {
            do {
                print("📋 PDF LOADING: Fetching record from CloudKit...")
                let recordStartTime = Date()
                let record = try await container.publicCloudDatabase.record(for: reference.recordID)
                let recordFetchDuration = Date().timeIntervalSince(recordStartTime)
                print("📋 PDF LOADING: Record fetched in \(String(format: "%.3f", recordFetchDuration))s")
                
                if let recordName = record["title"] as? String {
                    print("📋 PDF LOADING: PDF title: \(recordName)")
                }
                
                await MainActor.run {
                    if let asset = record["pdfFile"] as? CKAsset, let fileURL = asset.fileURL {
                        print("📋 PDF LOADING: PDF file URL: \(fileURL.lastPathComponent)")
                        
                        // Try to get file size and metadata
                        if let fileAttributes = try? FileManager.default.attributesOfItem(atPath: fileURL.path) {
                            if let fileSize = fileAttributes[.size] as? Int64 {
                                let fileSizeKB = Double(fileSize) / 1024.0
                                print("📋 PDF LOADING: File size: \(String(format: "%.1f", fileSizeKB)) KB")
                                
                                if fileSize <= 0 {
                                    self.isLoadingPDF = false
                                    self.pdfError = isSpanish ? 
                                        "El archivo PDF está vacío" : 
                                        "PDF file is empty"
                                    print("❌ PDF LOADING: Error - File size is zero or negative")
                                    completion()
                                    return
                                }
                            }
                            
                            if let creationDate = fileAttributes[.creationDate] as? Date {
                                print("📋 PDF LOADING: File creation date: \(creationDate.formatted())")
                            }
                            
                            if let modificationDate = fileAttributes[.modificationDate] as? Date {
                                print("📋 PDF LOADING: File modification date: \(modificationDate.formatted())")
                            }
                        }
                        
                        // Try direct loading first
                        print("📋 PDF LOADING: Attempting to load PDF from URL...")
                        let pdfLoadStartTime = Date()
                        if let document = PDFKit.PDFDocument(url: fileURL) {
                            let pdfLoadDuration = Date().timeIntervalSince(pdfLoadStartTime)
                            print("📋 PDF LOADING: PDF loaded in \(String(format: "%.3f", pdfLoadDuration))s")
                            print("📋 PDF LOADING: PDF page count: \(document.pageCount)")
                            
                            if let attributes = document.documentAttributes {
                                print("📋 PDF LOADING: PDF attributes: \(attributes.keys.map { $0.rawValue }.joined(separator: ", "))")
                                if let title = attributes[PDFDocumentAttribute.titleAttribute] as? String {
                                    print("📋 PDF LOADING: PDF title: \(title)")
                                }
                                if let creator = attributes[PDFDocumentAttribute.creatorAttribute] as? String {
                                    print("📋 PDF LOADING: PDF creator: \(creator)")
                                }
                            }
                            
                            if document.pageCount > 0 {
                                // Log first page dimensions
                                if let firstPage = document.page(at: 0) {
                                    let pageBounds = firstPage.bounds(for: .mediaBox)
                                    print("📋 PDF LOADING: First page dimensions: \(pageBounds.width) x \(pageBounds.height) points")
                                }
                                
                                // Use a longer delay to ensure UI is ready
                                DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                                    self.linkedPDF = document
                                    self.isLoadingPDF = false
                                    self.pdfReadyForDisplay = true
                                    let totalDuration = Date().timeIntervalSince(startTime)
                                    print("✅ PDF LOADING: Successfully loaded PDF in \(String(format: "%.3f", totalDuration))s")
                                    completion()
                                }
                            } else {
                                self.isLoadingPDF = false
                                self.pdfError = isSpanish ?
                                    "El documento PDF no tiene páginas" :
                                    "PDF document has no pages"
                                print("❌ PDF LOADING: Error - PDF has no pages")
                                completion()
                            }
                        } else {
                            // Try with data as fallback
                            print("📋 PDF LOADING: Direct URL loading failed, trying with data...")
                            do {
                                let dataLoadStartTime = Date()
                                let data = try Data(contentsOf: fileURL)
                                let dataLoadDuration = Date().timeIntervalSince(dataLoadStartTime)
                                print("📋 PDF LOADING: Data loaded in \(String(format: "%.3f", dataLoadDuration))s, size: \(data.count) bytes")
                                
                                if data.count > 0 {
                                    let pdfFromDataStartTime = Date()
                                    if let document = PDFKit.PDFDocument(data: data) {
                                        let pdfFromDataDuration = Date().timeIntervalSince(pdfFromDataStartTime)
                                        print("📋 PDF LOADING: PDF created from data in \(String(format: "%.3f", pdfFromDataDuration))s")
                                        print("📋 PDF LOADING: PDF page count: \(document.pageCount)")
                                        
                                        if document.pageCount > 0 {
                                            DispatchQueue.main.asyncAfter(deadline: .now() + 0.3) {
                                                self.linkedPDF = document
                                                self.isLoadingPDF = false
                                                self.pdfReadyForDisplay = true
                                                let totalDuration = Date().timeIntervalSince(startTime)
                                                print("✅ PDF LOADING: Successfully loaded PDF from data in \(String(format: "%.3f", totalDuration))s")
                                                completion()
                                            }
                                        } else {
                                            self.isLoadingPDF = false
                                            self.pdfError = isSpanish ?
                                                "El documento PDF no tiene páginas" :
                                                "PDF document has no pages"
                                            print("❌ PDF LOADING: Error - PDF from data has no pages")
                                            completion()
                                        }
                                    } else {
                                        self.isLoadingPDF = false
                                        self.pdfError = isSpanish ?
                                            "No se pudo crear el documento PDF" :
                                            "Could not create PDF document"
                                        print("❌ PDF LOADING: Error - Failed to create PDF from data")
                                        completion()
                                    }
                                } else {
                                    self.isLoadingPDF = false
                                    self.pdfError = isSpanish ?
                                        "El archivo PDF está vacío" :
                                        "PDF file is empty"
                                    print("❌ PDF LOADING: Error - Data is empty")
                                    completion()
                                }
                            } catch {
                                self.isLoadingPDF = false
                                self.pdfError = isSpanish ?
                                    "Error al leer los datos del archivo: \(error.localizedDescription)" :
                                    "Error reading file data: \(error.localizedDescription)"
                                print("❌ PDF LOADING: Error reading file data - \(error.localizedDescription)")
                                completion()
                            }
                        }
                    } else {
                        self.isLoadingPDF = false
                        self.pdfError = isSpanish ?
                            "No se encontró el archivo PDF" :
                            "PDF file not found"
                        print("❌ PDF LOADING: Error - PDF asset not found in record")
                        completion()
                    }
                }
            } catch {
                await MainActor.run {
                    self.isLoadingPDF = false
                    self.pdfError = isSpanish ?
                        "Error al cargar el PDF: \(error.localizedDescription)" :
                        "Error loading PDF: \(error.localizedDescription)"
                    print("❌ PDF LOADING: Error fetching record - \(error.localizedDescription)")
                    completion()
                }
            }
        }
    }
}

// MARK: - PDF Viewer for Archived News
struct ArchivedNewsPDFViewer: NSViewRepresentable {
    let document: PDFKit.PDFDocument
    @Binding var refreshTrigger: Bool
    
    func makeNSView(context: Context) -> PDFView {
        let pdfView = PDFView()
        print("\n📄 PDF VIEWER: Creating new PDFView instance")
        print("📄 PDF VIEWER: Document has \(document.pageCount) pages")
        
        if document.pageCount == 0 {
            print("⚠️ PDF VIEWER WARNING: Document has no pages!")
        }
        
        // Add visual debugging boundary
        pdfView.wantsLayer = true
        pdfView.layer?.borderWidth = 1.0
        pdfView.layer?.borderColor = NSColor.systemBlue.cgColor
        
        // Configure PDFView with optimal settings
        pdfView.autoScales = true
        pdfView.displayMode = .singlePageContinuous
        pdfView.displayDirection = .vertical
        pdfView.backgroundColor = NSColor.textBackgroundColor
        
        // Enable page navigation
        pdfView.displaysPageBreaks = true
        pdfView.displaysAsBook = false
        pdfView.autoresizingMask = [.width, .height]
        pdfView.minScaleFactor = 0.1
        pdfView.maxScaleFactor = 4.0
        
        print("📄 PDF VIEWER: PDFView initial frame: \(pdfView.frame)")
        
        // Set the document
        print("📄 PDF VIEWER: Setting document on PDFView")
        pdfView.document = document
        
        if pdfView.document == nil {
            print("⚠️ PDF VIEWER WARNING: Document didn't set properly!")
        } else {
            print("✅ PDF VIEWER: Document set successfully")
        }
        
        // Force layout
        pdfView.needsLayout = true
        pdfView.layoutSubtreeIfNeeded()
        
        // Set initial scale to fit - safely unwrap optional page
        if let page = document.page(at: 0) {
            let pageBounds = page.bounds(for: .mediaBox)
            let viewWidth = pdfView.frame.width
            let viewHeight = pdfView.frame.height
            
            print("📄 PDF VIEWER: Page bounds: \(pageBounds.width) x \(pageBounds.height)")
            print("📄 PDF VIEWER: View dimensions: \(viewWidth) x \(viewHeight)")
            
            // Check if dimensions are valid before calculating scale
            if viewWidth > 0 && viewHeight > 0 && pageBounds.width > 0 && pageBounds.height > 0 {
                let widthScale = viewWidth / pageBounds.width
                let heightScale = viewHeight / pageBounds.height
                let scaleFactor = min(widthScale, heightScale) * 0.9
                let finalScale = max(0.5, scaleFactor)
                
                print("📄 PDF VIEWER: Width scale: \(widthScale), Height scale: \(heightScale)")
                print("📄 PDF VIEWER: Calculated scale factor: \(scaleFactor)")
                print("📄 PDF VIEWER: Final applied scale: \(finalScale)")
                
                pdfView.scaleFactor = finalScale
            } else {
                print("⚠️ PDF VIEWER WARNING: Invalid dimensions, using default scale factor")
                pdfView.scaleFactor = 1.0
            }
            
            // Navigate to first page
            pdfView.go(to: page)
            print("📄 PDF VIEWER: Navigated to first page")
        } else {
            print("⚠️ PDF VIEWER WARNING: Could not access first page of document")
        }
        
        // Final state check
        print("📄 PDF VIEWER: Final PDFView frame: \(pdfView.frame)")
        print("📄 PDF VIEWER: Final scale factor: \(pdfView.scaleFactor)")
        print("📄 PDF VIEWER: Current page: \(pdfView.currentPage?.pageRef?.pageNumber ?? -1)")
        
        return pdfView
    }
    
    func updateNSView(_ pdfView: PDFView, context: Context) {
        print("\n📄 PDF VIEWER UPDATE: Refreshing PDFView")
        print("📄 PDF VIEWER UPDATE: Document has \(document.pageCount) pages")
        print("📄 PDF VIEWER UPDATE: First page exists: \(document.page(at: 0) != nil ? "YES" : "NO")")
        print("📄 PDF VIEWER UPDATE: Current view frame: \(pdfView.frame)")
        
        // Ensure document is set
        if pdfView.document != document {
            print("📄 PDF VIEWER UPDATE: Setting new document instance")
            pdfView.document = document
            
            if pdfView.document == nil {
                print("⚠️ PDF VIEWER UPDATE WARNING: Document didn't set properly!")
            } else {
                print("✅ PDF VIEWER UPDATE: Document set successfully")
            }
        } else {
            print("📄 PDF VIEWER UPDATE: Document already set correctly")
        }
        
        // Force layout and scaling
        print("📄 PDF VIEWER UPDATE: Forcing layout refresh")
        pdfView.needsLayout = true
        pdfView.layoutSubtreeIfNeeded()
        
        // Update scale to fit - safely unwrap optional page
        if let page = document.page(at: 0) {
            let pageBounds = page.bounds(for: .mediaBox)
            let viewWidth = pdfView.frame.width
            let viewHeight = pdfView.frame.height
            
            print("📄 PDF VIEWER UPDATE: Page bounds: \(pageBounds.width) x \(pageBounds.height)")
            print("📄 PDF VIEWER UPDATE: View dimensions: \(viewWidth) x \(viewHeight)")
            
            // Check if dimensions are valid before calculating scale
            if viewWidth > 0 && viewHeight > 0 && pageBounds.width > 0 && pageBounds.height > 0 {
                let widthScale = viewWidth / pageBounds.width
                let heightScale = viewHeight / pageBounds.height
                let scaleFactor = min(widthScale, heightScale) * 0.9
                let finalScale = max(0.5, scaleFactor)
                
                let previousScale = pdfView.scaleFactor
                print("📄 PDF VIEWER UPDATE: Previous scale: \(previousScale)")
                print("📄 PDF VIEWER UPDATE: Width scale: \(widthScale), Height scale: \(heightScale)")
                print("📄 PDF VIEWER UPDATE: Calculated scale factor: \(scaleFactor)")
                print("📄 PDF VIEWER UPDATE: Final applied scale: \(finalScale)")
                
                pdfView.scaleFactor = finalScale
            } else {
                print("⚠️ PDF VIEWER UPDATE WARNING: Invalid dimensions for scaling calculation")
            }
        } else {
            print("⚠️ PDF VIEWER UPDATE WARNING: Could not access first page of document for scaling")
        }
        
        // Force a refresh when the trigger changes
        if refreshTrigger {
            print("📄 PDF VIEWER UPDATE: Refresh trigger activated")
            pdfView.needsLayout = true
            pdfView.layoutSubtreeIfNeeded()
            
            // Safely handle optional page - this addresses the force unwrapping issue
            if document.pageCount > 0, let firstPage = document.page(at: 0) {
                print("📄 PDF VIEWER UPDATE: Refreshing and going to first page")
                pdfView.go(to: firstPage)
                
                // Also check if the page is actually displayed
                DispatchQueue.main.asyncAfter(deadline: .now() + 0.2) {
                    print("📄 PDF VIEWER UPDATE: After delay - current page: \(pdfView.currentPage?.pageRef?.pageNumber ?? -1)")
                    print("📄 PDF VIEWER UPDATE: After delay - visible page count: \(pdfView.visiblePages?.count ?? 0)")
                    print("📄 PDF VIEWER UPDATE: After delay - scale factor: \(pdfView.scaleFactor)")
                }
            } else {
                print("⚠️ PDF VIEWER UPDATE WARNING: Cannot navigate to first page on refresh, document may be empty")
                print("📄 PDF VIEWER UPDATE: Document is \(document), page count: \(document.pageCount)")
            }
            
            // Reset the trigger
            print("📄 PDF VIEWER UPDATE: Resetting refresh trigger")
            DispatchQueue.main.async {
                refreshTrigger = false
            }
        }
        
        // Final state check
        print("📄 PDF VIEWER UPDATE: Final PDFView frame: \(pdfView.frame)")
        print("📄 PDF VIEWER UPDATE: Final scale factor: \(pdfView.scaleFactor)")
        print("📄 PDF VIEWER UPDATE: Current page: \(pdfView.currentPage?.pageRef?.pageNumber ?? -1)")
    }
}

// MARK: - PDF Preview Component
struct PDFPreview: NSViewRepresentable {
    let document: PDFKit.PDFDocument
    
    func makeNSView(context: Context) -> PDFView {
        let pdfView = PDFView()
        pdfView.document = document
        return pdfView
    }
    
    func updateNSView(_ nsView: PDFView, context: Context) {
        nsView.document = document
    }
}

#Preview {
    ArchivedNewsView(isSpanish: .constant(false), refreshTrigger: .constant(false))
} 
